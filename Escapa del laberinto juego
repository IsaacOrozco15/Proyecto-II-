# Segundo proyecto de introducción a la programación - Escapa del Laberinto
# Isaac Orozco y Daniel Araya
#

# Imports estándar de Python
import random
import time
import json
import os
import datetime
from collections import deque, namedtuple

# Imports de tkinter 
import tkinter as tk
from tkinter import messagebox, simpledialog, ttk

# (Asegúrate de tener `from PIL import Image, ImageTk` arriba del archivo o manejar el fallback)
try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except Exception:
    PIL_AVAILABLE = False

FILAS = 12
COLUMNAS = 18

NUM_ENEMIGOS = 3
TIEMPO_REAPARICION_ENEMIGO = 10  # segundos
COOLDOWN_TRAMPA = 5  # segundos entre colocaciones
MAX_TRAMPAS_ACTIVAS = 3

COSTO_CORRER_POR_MOVIMIENTO = 10
RECUPERACION_ENERGIA_POR_TURNO = 5
ENERGIA_MAXIMA = 100

ARCHIVO_PUNTAJES_ESCAPA = "puntajes_escapa.txt"
ARCHIVO_PUNTAJES_CAZADOR = "puntajes_cazador.txt"

Punto = namedtuple("Punto", ["r", "c"])


def dentro(r, c):  # Verifica si una posición está dentro del mapa
    return 0 <= r < FILAS and 0 <= c < COLUMNAS


# CLASES DE CASILLAS

class Casilla:  # CLASE BASE

    simbolo = "?"

    def accesible_por_jugador(self):
        return False

    def accesible_por_enemigo(self):
        return False

    def __str__(self):
        return self.simbolo


class Camino(Casilla):
    simbolo = "."

    def accesible_por_jugador(self): return True

    def accesible_por_enemigo(self): return True

class Liana(Casilla):
    simbolo = "L"
    imagen = None
    imagen_path = None

    @classmethod
    def init_imagen_path(cls):
        if cls.imagen_path is None:
            base = os.path.dirname(os.path.abspath(__file__))
            cls.imagen_path = os.path.join(base, "Objetos", "liana.png")

    @classmethod
    def cargar_imagen(cls, tamano):
        cls.init_imagen_path()
        if not os.path.exists(cls.imagen_path):
            cls.imagen = None
            print(f"[Liana] No encontrado: {cls.imagen_path}")
            return
        try:
            if PIL_AVAILABLE:
                img = Image.open(cls.imagen_path).convert("RGBA")
                img = img.resize((tamano, tamano), Image.Resampling.LANCZOS)
                cls.imagen = ImageTk.PhotoImage(img)
            else:
                cls.imagen = tk.PhotoImage(file=cls.imagen_path)
        except Exception as e:
            print(f"[Liana] Error cargando imagen '{cls.imagen_path}': {e}")
            cls.imagen = None

    def accesible_por_jugador(self): return False
    def accesible_por_enemigo(self): return True



class Tunel(Casilla):
    simbolo = "T"

    def accesible_por_jugador(self): return True

    def accesible_por_enemigo(self): return False



class Muro(Casilla):
    simbolo = "#"
    imagen = None            # PhotoImage cached
    imagen_path = None       # ruta absoluta al PNG usado por la clase

    @classmethod
    def init_imagen_path(cls):
        # determina la ruta relativa correcta basada en la ubicación del script
        if cls.imagen_path is None:
            base = os.path.dirname(os.path.abspath(__file__))
            cls.imagen_path = os.path.join(base, "Objetos", "muro.png")

    @classmethod
    def cargar_imagen(cls, tamano):
        """
        Carga y escala la imagen del muro a (tamano x tamano).
        - Debe llamarse DESPUÉS de crear el Tk() principal.
        - Guarda la PhotoImage en cls.imagen (evita GC).
        """
        cls.init_imagen_path()
        if not os.path.exists(cls.imagen_path):
            # No existe el asset: dejar imagen en None (fallback a rectángulo)
            cls.imagen = None
            # opcional: print para depuración
            print(f"[Muro] No encontrado: {cls.imagen_path}")
            return

        try:
            if PIL_AVAILABLE:
                img = Image.open(cls.imagen_path).convert("RGBA")
                # redimensionar con filtro de alta calidad
                img = img.resize((tamano, tamano), Image.Resampling.LANCZOS)
                cls.imagen = ImageTk.PhotoImage(img)
            else:
                # PhotoImage no escala; se espera que la imagen ya tenga el tamaño correcto
                cls.imagen = tk.PhotoImage(file=cls.imagen_path)
        except Exception as e:
            print(f"[Muro] Error cargando imagen '{cls.imagen_path}': {e}")
            cls.imagen = None

    def accesible_por_jugador(self): return False

    def accesible_por_enemigo(self): return False



class Salida(Casilla):
    simbolo = "S"

    def accesible_por_jugador(self): return True

    def accesible_por_enemigo(self): return False  # Los cazadores no pueden usar las salidas


class Trampa(Casilla):
    def __init__(self):
        self.activa = True
        self.tiempo_colocacion = time.time()

    simbolo = "X"

    def accesible_por_jugador(self): return True

    def accesible_por_enemigo(self): return True

    def activar_trampa(self):
        """Activa la trampa cuando un enemigo la toca"""
        self.activa = False
        return True  # Indica que el enemigo debe ser eliminado